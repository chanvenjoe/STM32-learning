C51 COMPILER V9.60.0.0   WS2811                                                            04/13/2022 23:59:47 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE WS2811
OBJECT MODULE PLACED IN .\Objects\WS2811.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Functions\WS2811.c COMPACT OPTIMIZE(0,SPEED) BROWSE INCDIR(..\Include) D
                    -EFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\Listings\WS2811.lst) OBJECT(.\Objects\WS2811.obj)

line level    source

   1          #include "WS2811.h"
   2          #include "N76E003.h"
   3          
   4          /***********TYPE DEFINE****************/
   5          
   6          
   7          
   8          /***********VARIABLE DEFINE************/
   9          
  10          /***********Constant variable**********/
  11          
  12          #define RGB_HSV 0               //1 to enable transformation  code
  13          /**************************************/
  14          
  15          Color_Typedef LED_Buf[LEDNUM];
  16          
  17          void WS_Send24bits(u32 color)//Be Careful about the direction of rope: Din->Dout
  18          {
  19   1              u8 i;
  20   1              for(i=0;i<24;i++)
  21   1              {
  22   2                      if(color & 0x00800000)// 0000 0000 1000 0000... the highest bit & color, then the MCU can send 24bits da
             -ta to WS2812
  23   2                      {
  24   3                              CODE_1
  25   3                      }
  26   2                      else CODE_0
  27   2                      color<<=1;
  28   2              }
  29   1      }
  30          
  31          void WS_Color_copy(u8 No, u32 color)
  32          {
  33   1              LED_Buf[No].RGB = color;
  34   1      }
  35          
  36          void WS_ColorSet_LED(u8 from, u8 to, u32 color)
  37          {
  38   1              static int temp;
  39   1              if(from>to)
  40   1              {
  41   2                      temp=from; from=to; to=temp;
  42   2              }
  43   1              for(temp = from;temp<=to; temp++)
  44   1              {
  45   2                      WS_Color_copy(temp, color);
  46   2              }
  47   1      }
  48          
  49          void WS_Refresh()
  50          {
  51   1              u8 i;
  52   1              WS_Send24bits(dummy);
  53   1              for( i=0;i<=LEDNUM+1;i++)
C51 COMPILER V9.60.0.0   WS2811                                                            04/13/2022 23:59:47 PAGE 2   

  54   1              {
  55   2                      WS_Send24bits(LED_Buf[i].RGB);
  56   2              }
  57   1              RES
  58   1      }
  59          
  60          void WS_Key_RGB(void)
  61          {
  62   1              static u8 temp = 0;
  63   1              switch (temp)
  64   1              {
  65   2                      case 0:
  66   2                              WS_ColorSet_LED(0, LEDNUM, Black);
  67   2                              WS_Refresh();
  68   2                              WS_ColorSet_LED(0, 3, Red);
  69   2                              WS_Refresh();
  70   2                              break;
  71   2                      case 1:
  72   2                              WS_ColorSet_LED(0, LEDNUM, Black);
  73   2                              WS_Refresh();
  74   2                              WS_ColorSet_LED(4, 6, Blue);
  75   2                              WS_Refresh();
  76   2                              break;
  77   2                      case 2:
  78   2                              WS_ColorSet_LED(0, LEDNUM, Black);
  79   2                              WS_Refresh();
  80   2                              WS_ColorSet_LED(7,10, Green);
  81   2                              WS_Refresh();
  82   2                              break;
  83   2              }
  84   1              temp++;
  85   1              if(temp>2)
  86   1                      temp = 0;
  87   1                              
  88   1                      
  89   1      //              WS_Refresh();
  90   1                      Timer0_Delay1ms(50);
  91   1      }
  92          
  93          
  94          void WS_Hue_change()
  95          {
  96   1              u8 cylon=160;
  97   1              u8 cycle;
  98   1      //      u32 temp;
  99   1              static int h=160;
 100   1              if(h>=0&&h<360)
 101   1              {
 102   2                      for(cycle=0;cycle<=LEDNUM;cycle++)
 103   2                      {
 104   3                              WS_ColorSet_LED(0, cycle, HSV_RGB(h, 1,1,0,0,0));
 105   3                              WS_Refresh();
 106   3                              Timer0_Delay1ms(50);
 107   3                      }
 108   2                      h+=15;
 109   2              }
 110   1                      else
 111   1                              h=0;
 112   1      }
 113          //u32 CapacitiveTouch_Init(u16 psc)
 114          //{
 115          //      u32 array[10];
C51 COMPILER V9.60.0.0   WS2811                                                            04/13/2022 23:59:47 PAGE 3   

 116          //      u16 temp;
 117          //      u8 i,j;
 118          //      Tpad_IOInit(psc);
 119          //      for(i=0;i<10;i++)
 120          //      {
 121          //              array[i] = TPAD_Get_Val();
 122          //              void Timer0_Delay1ms(10);
 123          //      }
 124          //      for(i=0;i<9;i++)
 125          //      {
 126          //              for(j=i+1;j<10;j++)
 127          //              {
 128          //                      if(array[i]>array[j])
 129          //                      {
 130          //                              temp = array[j];
 131          //                              array[j] = array[i];
 132          //                              array[i] = temp;
 133          //                      }
 134          //              }
 135          //      }
 136          //      temp = 0;
 137          //      for(i=2;i<8;i++) temp+=array[i];
 138          //      tpad_average = temp/6;
 139          ////    printf("tpad value is:%d\n", tpad_average);
 140          ////    if(tpad_average >TPAD_ARR_MAX_VAL/2) //printf("initialization faild");
 141          //              
 142          //      return tpad_average;
 143          //}
 144          
 145          
 146          //void TPAD_Reset(void)
 147          //{
 148          //      GPIO_Configg.GPIO_Pin = GPIO_Pin_5;
 149          //      GPIO_Configg.GPIO_Mode = GPIO_Mode_OUT;
 150          //      GPIO_Configg.GPIO_PuPd = GPIO_PuPd_DOWN; 
 151          //      GPIO_Init(GPIOA, &GPIO_Configg);
 152          //      GPIO_ResetBits(GPIOA, GPIO_Pin_5);
 153          //      
 154          //      void Timer0_Delay1ms(50);
 155          //      TIM_ClearITPendingBit(TIM2, TIM_IT_CC1|TIM_IT_Update);
 156          //      TIM_SetCounter(TIM2,0);
 157          //      
 158          //      GPIO_Configg.GPIO_Pin = GPIO_Pin_5;
 159          //      GPIO_Configg.GPIO_Mode = GPIO_Mode_AF;
 160          //      GPIO_Configg.GPIO_PuPd = GPIO_PuPd_NOPULL;
 161          //      GPIO_Init(GPIOA,&GPIO_Configg);
 162          //}
 163          
 164          //u16 TPAD_Get_Val(void)
 165          //{
 166          //      TPAD_Reset();
 167          //      while(TIM_GetFlagStatus(TIM2, TIM_IT_CC1) == RESET)
 168          //      {
 169          //              if(TIM_GetCounter(TIM2)>TPAD_ARR_MAX_VAL-500)
 170          //              return TIM_GetCounter(TIM2);
 171          //      }
 172          //      return TIM_GetCapture1(TIM2);
 173          //}
 174          
 175          //u8 TPAD_Scan(u8 mode,u32 tpad_average1)
 176          //{
 177          //      static u8 keyen=0; //enable touch
C51 COMPILER V9.60.0.0   WS2811                                                            04/13/2022 23:59:47 PAGE 4   

 178          //      u8 res=0;
 179          //      u8 sample=3;
 180          //      u16 rval;
 181          //      if(mode)
 182          //      {
 183          //              sample=6;
 184          //              keyen=0;
 185          //      }
 186          //      rval=TPAD_Get_MaxVal(sample);
 187          //      if(rval>(tpad_average1+TPAD_GATE_VAL)&&(keyen==0))
 188          //      {
 189          //              res=1;
 190          //              keyen = 0;
 191          //      }
 192          //      
 193          //      return res;
 194          //}
 195          //      
 196          //u16 TPAD_Get_MaxVal(u8 sampt)
 197          //{
 198          //      u16 temp=0;
 199          //      u16 res=0;
 200          //      while(sampt--)
 201          //      {
 202          //              temp = TPAD_Get_Val();
 203          //              if(temp>res) res = temp;
 204          //      }
 205          //      return res;
 206          //}
 207          
 208          //void Tpad_IOInit(u16 psc)
 209          //{
 210          //      //GPIOA init
 211          //      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 212          //      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
 213          //      
 214          //      GPIO_Configg.GPIO_Mode = GPIO_Mode_AF;
 215          //      GPIO_Configg.GPIO_OType= GPIO_OType_PP;
 216          //      GPIO_Configg.GPIO_Pin  = GPIO_Pin_5 | GPIO_Pin_0;
 217          //      GPIO_Configg.GPIO_PuPd = GPIO_PuPd_NOPULL;
 218          //      GPIO_Configg.GPIO_Speed= GPIO_Speed_100MHz; //related to the power consumption and reaction speed;
 219          //      GPIO_Init(GPIOA, &GPIO_Configg);
 220          //      GPIO_PinAFConfig(GPIOA, GPIO_PinSource5,GPIO_AF_TIM2);
 221          //      
 222          //      //TIMER2_Init
 223          //      TimeBase_Init.TIM_ClockDivision = TIM_CKD_DIV1;
 224          //      TimeBase_Init.TIM_CounterMode = TIM_CounterMode_Up;
 225          //      TimeBase_Init.TIM_Period = TPAD_ARR_MAX_VAL;
 226          //      TimeBase_Init.TIM_Prescaler = psc-1;
 227          //      TimeBase_Init.TIM_RepetitionCounter = 0;
 228          //      TIM_TimeBaseInit(TIM2,&TimeBase_Init);
 229          //      TIM_Cmd(TIM2,ENABLE);
 230          //      
 231          ////    TIM_ITConfig(TIM2,TIM_IT_Update|TIM_IT_CC1,ENABLE);//Enable the interrupt and capture
 232          //      
 233          //      //Input capture init
 234          //      InputCapture_init.TIM_Channel = TIM_Channel_1;
 235          //      InputCapture_init.TIM_ICFilter= 0x00;
 236          //      InputCapture_init.TIM_ICPolarity= TIM_ICPolarity_Rising;
 237          //      InputCapture_init.TIM_ICPrescaler = TIM_ICPSC_DIV1;
 238          //      InputCapture_init.TIM_ICSelection = TIM_ICSelection_DirectTI;
 239          //      TIM_ICInit(TIM2, &InputCapture_init);
C51 COMPILER V9.60.0.0   WS2811                                                            04/13/2022 23:59:47 PAGE 5   

 240          
 241          //      
 242          ////    //Timer priority setting
 243          ////    NVIC_init.NVIC_IRQChannel = TIM2_IRQn;//found from Stm32f4xx.h
 244          ////    NVIC_init.NVIC_IRQChannelPreemptionPriority =1;
 245          ////    NVIC_init.NVIC_IRQChannelSubPriority = 1;
 246          ////    NVIC_init.NVIC_IRQChannelCmd = ENABLE;
 247          ////    NVIC_Init(&NVIC_init);
 248          //}
 249          
 250          #if(RGB_HSV)
              u8      Get_RGB_Max(u8 R, u8 G, u8 B)
              {
                      u8 Max=R;
                      if(Max<G)
                      {
                              Max=G;
                      }
                      if(Max<B)
                      {
                              Max=B;
                      }
                      return Max;
              }
              u8      Get_RGB_Main(u8 R, u8 G, u8 B)
              {
                      u8 Min=R;
                      if(Min>G)
                      {
                              Min=G;
                      }
                      if(Min>B)
                      {
                              Min=B;
                      }
                      return Min;
              }
              
              u8      Get_Hue_Val(u8 R, u8 G, u8 B)
              {
                      u8 Max, Min,Num,Hue;
                      Max = Get_RGB_Max(R,G,B);
                      Min = Get_RGB_Min(R,G,B);
                      if(Max==Min)
                      {
                              Num=First;
                      }
                      else if(Max==R&&(G>=B))
                      {
                              Num=Second;
                      }
                      else if(Max==R&&(G<B))
                      {
                              Num=Third;
                      }
                      else if(Max==G)
                      {
                              Num=Fourth;
                      }
                      else if(Max==B)
                      {
                              Num=Fifth;
C51 COMPILER V9.60.0.0   WS2811                                                            04/13/2022 23:59:47 PAGE 6   

                      }
                      else
                      {
                              Num=Non;
                      }
                      switch(Num)
                      {
                              case 0:
                              break;
                              case 1:
                                      Hue=0;
                              break;
                              case 2:
                                      Hue=60*((R-G)/(Max-Min));
                              break;
                              case 3:
                                      Hue=60*((R-G)/(Max-Min))+360;
                              break;
                              case 4:
                                      Hue=60*((R-G)/(Max-Min))+120;
                              break;
                              case 5:
                                      Hue=60*((R-G)/(Max-Min))+240;
                              break;
                      }
                      return Hue;
              }
              #else
 330          u32 HSV_RGB(int h, char s, char v, float R, float G, float B)
 331          {
 332   1              u32 RGB;
 333   1              u8 R8,G8,B8;
 334   1              char  i;
 335   1              float X,Y,Z,C;
 336   1              i = h/60;               //char i
 337   1              C = h;          //float C
 338   1              C = C/60-i;
 339   1      //      char X = C*(1- (abs((h/60)%2-1)));
 340   1              X = v*(1-s);
 341   1              Y = v*(1-(s*C));
 342   1              Z = v*(1-s*(1-C));
 343   1              
 344   1              switch(i)
 345   1              {
 346   2                      case 0:
 347   2                              R=v; G=Z; B=X;
 348   2                              break;
 349   2                      case 1:
 350   2                              R=Y; G=v; B=X;
 351   2                              break;
 352   2                      case 2:
 353   2                              R=X; G=v; B=Z;
 354   2                              break;
 355   2                      case 3:
 356   2                              R=X; G=Y; B=v;
 357   2                              break;
 358   2                      case 4:
 359   2                              R=Z; G=X; B=v;
 360   2                              break;
 361   2                      case 5:
 362   2                              R=v; G=X; B=Y;
 363   2                              break;
C51 COMPILER V9.60.0.0   WS2811                                                            04/13/2022 23:59:47 PAGE 7   

 364   2              }
 365   1              R8=R*255;
 366   1              G8=G*255;
 367   1              B8=B*255;
 368   1              RGB|=R8;
 369   1              RGB<<=8;
 370   1              RGB|=G8;
 371   1              RGB<<=8;
 372   1              RGB|=B8;
 373   1              return RGB;
 374   1      }
 375          
 376          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1775    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =    134    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
