C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/25/2021 18:52:30 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MOTOR_CONTROL
OBJECT MODULE PLACED IN .\Output\Motor_control.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\Motor_control.c OPTIMIZE(2,SPEED) BROWSE INCDIR(..\Include) DEFINE(
                    -FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\Motor_control.lst) OBJECT(.\Output\Motor_control.obj)

line level    source

   1          #include "Motor_control.h"
   2          #include "common.h"
   3          #include "Function_define.h"
   4          #include "N76E003.h"
   5          #include "SFR_Macro.h"
   6          #include "Delay.h" 
   7          #include "SFR_Macro.h"
   8          
   9          #define Vref  3072;
  10          #define set_IAPEN BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;CHPCON|=SET_BIT0 ;EA=BIT_TMP
  11          #define set_IAPGO BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;IAPTRG|=SET_BIT0 ;EA=BIT_TMP
  12          #define clr_IAPEN BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;CHPCON&=~SET_BIT0;EA=BIT_TMP
  13          ////////////Variables////////////////
  14          double bgvalue, ADCValue, bgvol, ADC_Vol;
  15          uint8_t  bgmark;
  16          uint8_t  bgh;
  17          uint8_t  bgl;
  18          
  19          
  20          // PWM+=KP[e(k) -e(k-1)]+Ki*e(k)+Kd[e(k)-2e(k-1)+e(k-2)]
  21          // e(k) the value difference of actual and setting e(k-1) the last time difference
  22          // In this motor control we use P
  23          // PWM = Kp[e(k) - e(k-1)]
  24          // Cbat == the current value  IO:P05 ADC value
  25          UINT8 Incremental_P(UINT8 Cbat, UINT8 CC_Value)
  26          {
  27   1              float Kp=1;
  28   1              static UINT8 Bias, PWM,Last_bias;
  29   1              Bias= Cbat-CC_Value;
  30   1              PWM-=Kp*(Bias-Last_bias);// Decreasement output
  31   1              Last_bias = Bias;
  32   1              if(PWM>0)
  33   1              {
  34   2                      return PWM; //The percentage of decreasment
  35   2              }
  36   1              else return 0;
  37   1      }
  38          
  39          void ADC_Init(void)
  40          {
  41   1      //      set_EA;
  42   1      //      set_EPI;//Enable Pin interrupt
  43   1      //      P13_Input_Mode;
  44   1      //      
  45   1      //      clr_PIPS1;
  46   1      //      clr_PIPS0;//pin1.
  47   1      //      set_PIT3;//cHANNEL 3 Edge triggered
  48   1      //      clr_PIPEN3;//P13 falling triggered
  49   1      //      set_PINEN3;
  50   1              clr_P00, clr_P10;
  51   1              clr_P12; //LED on
  52   1              
  53   1              
  54   1              set_P14; //Enable DCDC
C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/25/2021 18:52:30 PAGE 2   

  55   1              
  56   1              set_IAPEN;
  57   1              IAPAL = 0x0d; IAPAH = 0x00; IAPCN = 0x04;//0x04 =Read UID
  58   1              set_IAPGO;
  59   1              bgl = IAPFD;
  60   1              bgmark = bgl&0xf0;
  61   1              
  62   1              if(bgmark == 0x80)
  63   1              {
  64   2                      bgl = bgl&0x0f;                 
  65   2                      IAPAL = 0x0c;
  66   2                      IAPAH = 0x00; 
  67   2                      set_IAPGO;
  68   2                      bgh = IAPFD;
  69   2                      bgvalue = (bgh<<4)+bgl;
  70   2                      bgvol = bgvalue*3/4;
  71   2                      bgvol = bgvol- 33;
  72   2              }
  73   1              if(bgmark==0x00)
  74   1              {
  75   2                      bgl = bgl&0x0f;
  76   2                      IAPAL = 0X0C;
  77   2                      IAPAH = 0X00;
  78   2                      set_IAPGO;
  79   2                      bgh = IAPFD;
  80   2                      bgvalue = (bgh<<4)+bgl;
  81   2                      bgvol = bgvalue*3/4;
  82   2              }
  83   1              if(bgmark==0x90)
  84   1              {
  85   2                      IAPAL = 0x0E;
  86   2                      IAPAH = 0x00;
  87   2                      set_IAPGO;
  88   2                      bgh   = IAPFD;
  89   2                      IAPAL = 0x0F;
  90   2                      IAPAH = 0x00;
  91   2                      set_IAPGO;
  92   2                      bgl = IAPFD;
  93   2                      bgl = bgl&0x0f; 
  94   2                      bgvalue = (bgh<<4)+bgl;
  95   2                      bgvol = bgvalue*3/4;
  96   2              }
  97   1              printf("\nBandgap value:%d\n", bgvalue);
  98   1              printf("\nBandgap vo ltage:%dmV\n",bgvol);
  99   1              clr_IAPEN;              // turn off IAP
 100   1              
 101   1              Enable_ADC_AIN0;                //P17 Hall pedal
 102   1      //      Enable_ADC_AIN4;                //P05 A_Det
 103   1      //      Enable_ADC_AIN1;                //P30 Speed
 104   1              for(bgh =0;bgh<3;bgh++)
 105   1              {
 106   2                      clr_ADCF;
 107   2                      set_ADCS;
 108   2                      while(ADCF==0);
 109   2                      ADCValue = (ADCRH<<4)+ADCRL;
 110   2                      printf("ADC value:%d",ADCValue);
 111   2              }
 112   1      }
 113          /* AD value= Voltage*255/5  20A=57*/
 114          UINT16 Get_CurrentValue(void)
 115          {
 116   1              Enable_ADC_AIN4;
C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/25/2021 18:52:30 PAGE 3   

 117   1              clr_ADCF;
 118   1              set_ADCS;
 119   1      //      ADCValue = (ADCRH<<4)+ADCRL;
 120   1              printf("ADC value:%d",ADCValue);
 121   1              return ADCRH;
 122   1      }
 123          
 124          UINT16 Get_HallValue(void)
 125          {
 126   1              Enable_ADC_AIN0;
 127   1              clr_ADCF;
 128   1              set_ADCS;
 129   1      //      ADCValue = (ADCRH<<4)+ADCRL
 130   1      //      ADC_Vol = (bgvol*ADCValue/bgvalue);//All are decimal
 131   1              printf("ADCRH:%x\n",ADCRH);
 132   1      //      printf("ADCRL:%d",ADCRL);
 133   1      //      printf("ADC_voltage:%gmV\n",ADC_Vol);//%g don't print no meaning 0
 134   1              return ADCRH; //High 8 bits+ low 4 bits
 135   1      }
 136          
 137                  /**********************************************************************
 138                                                                  Dead time setting
 139                                                          DT=PDTCNT+1/Fsys  >Ton+Toff
 140                                                          2us= 32/16M
 141                  ********************************** 3  5************************************/
 142          void PWM_DEAD_TIME_VALUE(UINT16 DeadTimeData) //problem:when the deadtemphigh!=1, there is no dead time
 143          {
 144   1              UINT8 deadtmphigh,deadtmplow;
 145   1              deadtmplow = DeadTimeData;
 146   1              deadtmphigh = DeadTimeData>>8;
 147   1              BIT_TMP = EA;
 148   1              if (deadtmphigh==0x01)
 149   1              {
 150   2                      EA = 0;
 151   2                      TA = 0xAA;
 152   2                      TA = 0x55;
 153   2                      PDTEN|=0x10;
 154   2              }
 155   1              TA = 0xAA;
 156   1              TA = 0x55;
 157   1              PDTCNT = deadtmplow;
 158   1              EA = BIT_TMP;
 159   1      }
 160          
 161          void PWM_Init()
 162          {
 163   1              PWM5_P03_OUTPUT_ENABLE;
 164   1              PWM4_P01_OUTPUT_ENABLE;//Upper bridge
 165   1              PWM4_OUTPUT_INVERSE;
 166   1              PWM5_OUTPUT_INVERSE;    
 167   1              PWM_COMPLEMENTARY_MODE;//In this mode the dead time can work
 168   1              
 169   1              PWM_CLOCK_DIV_8;
 170   1      //      PWMPH = 0x07;
 171   1      //      PWMPL = 0xcf;   //1K
 172   1              PWMPH = 0x00;   //Period setting;
 173   1              PWMPL = 0x96;   //13.3KHz
 174   1              
 175   1              set_SFRPAGE;
 176   1              PWM5H = 0x00;
 177   1              PWM5L = 0x00;
 178   1              clr_SFRPAGE;
C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/25/2021 18:52:30 PAGE 4   

 179   1              
 180   1              PWM45_DEADTIME_ENABLE;
 181   1              PWM_DEAD_TIME_VALUE(32); //32=2us dead time     
 182   1              set_LOAD;
 183   1              set_PWMRUN;
 184   1              /**********************************************************************
 185   1              PWM frequency = Fpwm/((PWMPH,PWMPL) + 1) <Fpwm = Fsys/PWM_CLOCK_DIV> 
 186   1                                                                      = (16MHz/8)/(0x7CF + 1)
 187   1                                                                      = 1KHz (1ms)
 188   1              =(16MHz/8)/(0x96+1)
 189   1      
 190   1              ***********************************************************************/
 191   1      }
 192          
 193          void PWM_Setting(UINT16 n)      //1n = 1%
 194          {
 195   1              set_SFRPAGE; //PWM4\5 SETTING
 196   1              PWM4H = (0xff00&n)>>8;//Lower bridge P01
 197   1              if(n>100)
 198   1              {
 199   2                      PWM4L = 0x97;
 200   2              }
 201   1              else if(n==0)
 202   1              {
 203   2      //              PWM4H = 0X00;
 204   2                      PWM4L = 0X00;
 205   2              }
 206   1              else
 207   1              {
 208   2      //              PWM4H = n>>4;
 209   2      //              PWM4L = n&&0xf;
 210   2                      PWM4L = (n*3/2);
 211   2              }
 212   1      
 213   1              set_LOAD;
 214   1              set_PWMRUN;
 215   1      }
 216          
 217          //void PinInterrupt (void) interrupt 7
 218          //{
 219          //      printf("Falling edge intterrupt triggered");
 220          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1082    ----
   CONSTANT SIZE    =     66    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
