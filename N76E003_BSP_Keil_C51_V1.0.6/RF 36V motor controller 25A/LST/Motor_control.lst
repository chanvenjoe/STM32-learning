C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/23/2021 23:01:22 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MOTOR_CONTROL
OBJECT MODULE PLACED IN .\Output\Motor_control.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\Motor_control.c OPTIMIZE(2,SPEED) BROWSE INCDIR(..\Include) DEFINE(
                    -FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\Motor_control.lst) OBJECT(.\Output\Motor_control.obj)

line level    source

   1          #include "Motor_control.h"
   2          #include "common.h"
   3          #include "Function_define.h"
   4          #include "N76E003.h"
   5          #include "SFR_Macro.h"
   6          #include "Delay.h" 
   7          #include "SFR_Macro.h"
   8          
   9          #define Vref  3072;
  10          #define set_IAPEN BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;CHPCON|=SET_BIT0 ;EA=BIT_TMP
  11          #define set_IAPGO BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;IAPTRG|=SET_BIT0 ;EA=BIT_TMP
  12          #define clr_IAPEN BIT_TMP=EA;EA=0;TA=0xAA;TA=0x55;CHPCON&=~SET_BIT0;EA=BIT_TMP
  13          ////////////Variables////////////////
  14          double bgvalue, ADCValue, bgvol, ADC_Vol;
  15          uint8_t  bgmark;
  16          uint8_t  bgh;
  17          uint8_t  bgl;
  18          
  19          
  20          
  21          
  22          void ADC_Init(void)
  23          {
  24   1      //      set_EA;
  25   1      //      set_EPI;//Enable Pin interrupt
  26   1      //      P13_Input_Mode;
  27   1      //      
  28   1      //      clr_PIPS1;
  29   1      //      clr_PIPS0;//pin1.
  30   1      //      set_PIT3;//cHANNEL 3 Edge triggered
  31   1      //      clr_PIPEN3;//P13 falling triggered
  32   1      //      set_PINEN3;
  33   1              clr_P00, clr_P10;
  34   1              clr_P12; //LED on
  35   1              
  36   1              
  37   1              set_P14; //Enable DCDC
  38   1              
  39   1              set_IAPEN;
  40   1              IAPAL = 0x0d; IAPAH = 0x00; IAPCN = 0x04;//0x04 =Read UID
  41   1              set_IAPGO;
  42   1              bgl = IAPFD;
  43   1              bgmark = bgl&0xf0;
  44   1              
  45   1              if(bgmark == 0x80)
  46   1              {
  47   2                      bgl = bgl&0x0f;                 
  48   2                      IAPAL = 0x0c;
  49   2                      IAPAH = 0x00; 
  50   2                      set_IAPGO;
  51   2                      bgh = IAPFD;
  52   2                      bgvalue = (bgh<<4)+bgl;
  53   2                      bgvol = bgvalue*3/4;
  54   2                      bgvol = bgvol- 33;
C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/23/2021 23:01:22 PAGE 2   

  55   2              }
  56   1              if(bgmark==0x00)
  57   1              {
  58   2                      bgl = bgl&0x0f;
  59   2                      IAPAL = 0X0C;
  60   2                      IAPAH = 0X00;
  61   2                      set_IAPGO;
  62   2                      bgh = IAPFD;
  63   2                      bgvalue = (bgh<<4)+bgl;
  64   2                      bgvol = bgvalue*3/4;
  65   2              }
  66   1              if(bgmark==0x90)
  67   1              {
  68   2                      IAPAL = 0x0E;
  69   2                      IAPAH = 0x00;
  70   2                      set_IAPGO;
  71   2                      bgh   = IAPFD;
  72   2                      IAPAL = 0x0F;
  73   2                      IAPAH = 0x00;
  74   2                      set_IAPGO;
  75   2                      bgl = IAPFD;
  76   2                      bgl = bgl&0x0f; 
  77   2                      bgvalue = (bgh<<4)+bgl;
  78   2                      bgvol = bgvalue*3/4;
  79   2              }
  80   1              printf("\nBandgap value:%d\n", bgvalue);
  81   1              printf("\nBandgap vo ltage:%dmV\n",bgvol);
  82   1              clr_IAPEN;              // turn off IAP
  83   1              
  84   1              Enable_ADC_AIN0;                //P17 Hall pedal
  85   1      //      Enable_ADC_AIN4;                //P05 A_Det
  86   1      //      Enable_ADC_AIN1;                //P30 Speed
  87   1              for(bgh =0;bgh<3;bgh++)
  88   1              {
  89   2                      clr_ADCF;
  90   2                      set_ADCS;
  91   2                      while(ADCF==0);
  92   2                      ADCValue = (ADCRH<<4)+ADCRL;
  93   2                      printf("ADC value:%d",ADCValue);
  94   2              }
  95   1      }
  96          
  97          UINT16 Get_HallValue(void)
  98          {
  99   1      
 100   1              clr_ADCF;
 101   1              set_ADCS;
 102   1      //      ADCValue = (ADCRH<<4)+ADCRL
 103   1      //      ADC_Vol = (bgvol*ADCValue/bgvalue);//All are decimal
 104   1              printf("ADCRH:%x\n",ADCRH);
 105   1      //      printf("ADCRL:%d",ADCRL);
 106   1      //      printf("ADC_voltage:%gmV\n",ADC_Vol);//%g don't print no meaning 0
 107   1              return ADCRH; //High 8 bits+ low 4 bits
 108   1      }
 109          
 110                  /**********************************************************************
 111                                                                  Dead time setting
 112                                                          DT=PDTCNT+1/Fsys  >Ton+Toff
 113                                                          2us= 32/16M
 114                  ********************************** 3  5************************************/
 115          void PWM_DEAD_TIME_VALUE(UINT16 DeadTimeData) //problem:when the deadtemphigh!=1, there is no dead time
 116          {
C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/23/2021 23:01:22 PAGE 3   

 117   1              UINT8 deadtmphigh,deadtmplow;
 118   1              deadtmplow = DeadTimeData;
 119   1              deadtmphigh = DeadTimeData>>8;
 120   1              BIT_TMP = EA;
 121   1              if (deadtmphigh==0x01)
 122   1              {
 123   2                      EA = 0;
 124   2                      TA = 0xAA;
 125   2                      TA = 0x55;
 126   2                      PDTEN|=0x10;
 127   2              }
 128   1              TA = 0xAA;
 129   1              TA = 0x55;
 130   1              PDTCNT = deadtmplow;
 131   1              EA = BIT_TMP;
 132   1      }
 133          
 134          void PWM_Init()
 135          {
 136   1              PWM5_P03_OUTPUT_ENABLE;
 137   1              PWM4_P01_OUTPUT_ENABLE;//Upper bridge
 138   1              
 139   1              PWM_COMPLEMENTARY_MODE;//In this mode the dead time can work
 140   1              PWM_CLOCK_DIV_8;
 141   1      //      PWMPH = 0x07;
 142   1      //      PWMPL = 0xcf;   //1K
 143   1              PWMPH = 0x00;   //Period setting;
 144   1              PWMPL = 0x96;   //13.3KHz
 145   1              
 146   1              set_SFRPAGE;
 147   1              PWM4H = 0x00;
 148   1              PWM4L = 0x4b;
 149   1              clr_SFRPAGE;
 150   1              
 151   1              PWM45_DEADTIME_ENABLE;
 152   1              PWM_DEAD_TIME_VALUE(32); //32=2us dead time     
 153   1              set_LOAD;
 154   1              set_PWMRUN;
 155   1              /**********************************************************************
 156   1              PWM frequency = Fpwm/((PWMPH,PWMPL) + 1) <Fpwm = Fsys/PWM_CLOCK_DIV> 
 157   1                                                                      = (16MHz/8)/(0x7CF + 1)
 158   1                                                                      = 1KHz (1ms)
 159   1              =(16MHz/8)/(0x96+1)
 160   1      
 161   1              ***********************************************************************/
 162   1      }
 163          
 164          void PWM_Setting(UINT16 n)      //1n = 1%
 165          {
 166   1              set_SFRPAGE; //PWM4\5 SETTING
 167   1      //      printf("ADC value:%d\n",ADCValue);
 168   1      //      printf("ADC_voltage:%gmV\n",ADC_Vol);/
 169   1              PWM4H = (0xff00&n)>>8;//Lower bridge P01
 170   1              if(n>100)
 171   1              {
 172   2                      PWM4L = 0x97;
 173   2              }
 174   1              else if(n==0)
 175   1              {
 176   2      //              PWM4H = 0X00;
 177   2                      PWM4L = 0X00;
 178   2              }
C51 COMPILER V9.60.0.0   MOTOR_CONTROL                                                     10/23/2021 23:01:22 PAGE 4   

 179   1              else
 180   1              {
 181   2      //              PWM4H = n>>4;
 182   2      //              PWM4L = n&&0xf;
 183   2                      PWM4L = (n*3/2);
 184   2              }
 185   1      
 186   1              set_LOAD;
 187   1              set_PWMRUN;
 188   1      }
 189          
 190          //void PinInterrupt (void) interrupt 7
 191          //{
 192          //      printf("Falling edge intterrupt triggered");
 193          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    896    ----
   CONSTANT SIZE    =     66    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
